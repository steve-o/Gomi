/*
 * Note: this file originally auto-generated by mib2c using
 *  : mib2c.iterate.conf 17821 2009-11-11 09:00:00Z dts12 $
 */

#include "gomiMIB.hh"

#include <list>

/* Boost threading. */
#include <boost/thread/shared_mutex.hpp>

/* redirect namespace pollution */
#define U64 __netsnmp_U64

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* revert Net-snmp namespace pollution */
#undef U64
#define __netsnmp_LOG_EMERG	0
#define __netsnmp_LOG_ALERT	1
#define __netsnmp_LOG_CRIT	2
#define __netsnmp_LOG_ERR	3
#define __netsnmp_LOG_WARNING	4
#define __netsnmp_LOG_NOTICE	5
#define __netsnmp_LOG_INFO	6
#define __netsnmp_LOG_DEBUG	7
static_assert (__netsnmp_LOG_EMERG   == LOG_EMERG,   "LOG_EMERGE mismatch");
static_assert (__netsnmp_LOG_ALERT   == LOG_ALERT,   "LOG_ALERT mismatch");
static_assert (__netsnmp_LOG_CRIT    == LOG_CRIT,    "LOG_CRIT mismatch");
static_assert (__netsnmp_LOG_ERR     == LOG_ERR,     "LOG_ERR mismatch");
static_assert (__netsnmp_LOG_WARNING == LOG_WARNING, "LOG_WARNING mismatch");
static_assert (__netsnmp_LOG_NOTICE  == LOG_NOTICE,  "LOG_NOTICE mismatch");
static_assert (__netsnmp_LOG_INFO    == LOG_INFO,    "LOG_INFO mismatch");
static_assert (__netsnmp_LOG_DEBUG   == LOG_DEBUG,   "LOG_DEBUG mismatch");
#undef LOG_EMERG
#undef LOG_ALERT
#undef LOG_CRIT
#undef LOG_ERR
#undef LOG_WARNING
#undef LOG_NOTICE
#undef LOG_INFO
#undef LOG_DEBUG

#include "chromium/logging.hh"
#include "gomi.hh"
#include "provider.hh"
#include "client.hh"

namespace gomi {

/* http://en.wikipedia.org/wiki/Unix_epoch */
static const boost::posix_time::ptime kUnixEpoch (boost::gregorian::date (1970, 1, 1));

static int initialize_table_gomiPluginTable(void);
static Netsnmp_Node_Handler gomiPluginTable_handler;
static Netsnmp_First_Data_Point gomiPluginTable_get_first_data_point;
static Netsnmp_Next_Data_Point gomiPluginTable_get_next_data_point;
static Netsnmp_Free_Loop_Context gomiPluginTable_free_loop_context;

static int initialize_table_gomiPerformanceTable(void);
static Netsnmp_Node_Handler gomiPerformanceTable_handler;
static Netsnmp_First_Data_Point gomiPerformanceTable_get_first_data_point;
static Netsnmp_Next_Data_Point gomiPerformanceTable_get_next_data_point;
static Netsnmp_Free_Loop_Context gomiPerformanceTable_free_loop_context;

static int initialize_table_gomiClientTable(void);
static Netsnmp_Node_Handler gomiClientTable_handler;
static Netsnmp_First_Data_Point gomiClientTable_get_first_data_point;
static Netsnmp_Next_Data_Point gomiClientTable_get_next_data_point;
static Netsnmp_Free_Loop_Context gomiClientTable_free_loop_context;

static int initialize_table_gomiClientPerformanceTable(void);
static Netsnmp_Node_Handler gomiClientPerformanceTable_handler;
static Netsnmp_First_Data_Point gomiClientPerformanceTable_get_first_data_point;
static Netsnmp_Next_Data_Point gomiClientPerformanceTable_get_next_data_point;
static Netsnmp_Free_Loop_Context gomiClientPerformanceTable_free_loop_context;

static int initialize_table_gomiOutageMeasurementTable(void);
static Netsnmp_Node_Handler gomiOutageMeasurementTable_handler;
static Netsnmp_First_Data_Point gomiOutageMeasurementTable_get_first_data_point;
static Netsnmp_Next_Data_Point gomiOutageMeasurementTable_get_next_data_point;
static Netsnmp_Free_Loop_Context gomiOutageMeasurementTable_free_loop_context;

static int initialize_table_gomiOutageEventTable(void);
static Netsnmp_Node_Handler gomiOutageEventTable_handler;
static Netsnmp_First_Data_Point gomiOutageEventTable_get_first_data_point;
static Netsnmp_Next_Data_Point gomiOutageEventTable_get_next_data_point;
static Netsnmp_Free_Loop_Context gomiOutageEventTable_free_loop_context;

/* Convert Posix time to Unix Epoch time.
 */
template< typename TimeT >
inline
TimeT
to_unix_epoch (
	const boost::posix_time::ptime t
	)
{
	return (t - boost::posix_time::ptime (kUnixEpoch)).total_seconds();
}

/* Context during a SNMP query, lock on global list of gomi_t objects and iterator.
 */
class snmp_context_t
{
public:
	snmp_context_t (boost::shared_mutex& gomi_lock_, std::list<gomi::gomi_t*>& gomi_list_) :
		gomi_lock (gomi_lock_),
		gomi_list (gomi_list_),
		gomi_it (gomi_list.begin())
	{
	}

/* Plugins are owned by AE, locking is required. */
	boost::shared_lock<boost::shared_mutex> gomi_lock;
	std::list<gomi::gomi_t*>& gomi_list;
	std::list<gomi::gomi_t*>::iterator gomi_it;
	boost::shared_lock<boost::shared_mutex> clients_lock;
	boost::unordered_map<rfa::common::Handle*const, std::shared_ptr<client_t>>::iterator client_it;
	boost::unordered_map<std::string, std::shared_ptr<cool_t>>::iterator cool_it;
	boost::shared_lock<boost::shared_mutex> events_lock;
	boost::circular_buffer<event_t>::iterator event_it;

/* SNMP agent is not-reentrant, ignore locking. */
	static std::list<std::shared_ptr<snmp_context_t>> global_list;
};

std::list<std::shared_ptr<snmp_context_t>> snmp_context_t::global_list;

/* Initializes the gomiMIB module.
 */
bool
init_gomiMIB(void)
{
/* here we initialize all the tables we're planning on supporting */
	if (MIB_REGISTERED_OK != initialize_table_gomiPluginTable()) {
		LOG(ERROR) << "gomiPluginTable registration: see SNMP log for further details.";
		return false;
	}
	if (MIB_REGISTERED_OK != initialize_table_gomiPerformanceTable()) {
		LOG(ERROR) << "gomiPerformanceTable registration: see SNMP log for further details.";
		return false;
	}
	if (MIB_REGISTERED_OK != initialize_table_gomiClientTable()) {
		LOG(ERROR) << "gomiClientTable registration: see SNMP log for further details.";
		return false;
	}
	if (MIB_REGISTERED_OK != initialize_table_gomiClientPerformanceTable()) {
		LOG(ERROR) << "gomiClientPerformanceTable registration: see SNMP log for further details.";
		return false;
	}
	if (MIB_REGISTERED_OK != initialize_table_gomiOutageMeasurementTable()) {
		LOG(ERROR) << "gomiOutageMeasurementTable registration: see SNMP log for further details.";
		return false;
	}
	if (MIB_REGISTERED_OK != initialize_table_gomiOutageEventTable()) {
		LOG(ERROR) << "gomiOutageEventTable registration: see SNMP log for further details.";
		return false;
	}
	return true;
}

/* Initialize the gomiPluginTable table by defining its contents and how it's structured.
 */
static
int
initialize_table_gomiPluginTable(void)
{
	DLOG(INFO) << "initialize_table_gomiPluginTable()";

	static const oid gomiPluginTable_oid[] = {1,3,6,1,4,1,67,3,2,2};
	const size_t gomiPluginTable_oid_len = OID_LENGTH (gomiPluginTable_oid);
	netsnmp_handler_registration* reg = nullptr;
	netsnmp_iterator_info* iinfo = nullptr;
	netsnmp_table_registration_info* table_info = nullptr;

	reg = netsnmp_create_handler_registration (
		"gomiPluginTable",	gomiPluginTable_handler,
		gomiPluginTable_oid,	gomiPluginTable_oid_len,
		HANDLER_CAN_RONLY
		);
	if (nullptr == reg)
		goto error;

	table_info = SNMP_MALLOC_TYPEDEF (netsnmp_table_registration_info);
	if (nullptr == table_info)
		goto error;
	netsnmp_table_helper_add_indexes (table_info,
					  ASN_OCTET_STR,  /* index: gomiPluginId */
					  0);
	table_info->min_column = COLUMN_GOMIPLUGINWINDOWSREGISTRYKEY;
	table_info->max_column = COLUMN_GOMIPLUGINDEFAULTDAYCOUNT;
    
	iinfo = SNMP_MALLOC_TYPEDEF (netsnmp_iterator_info);
	if (nullptr == iinfo)
		goto error;
	iinfo->get_first_data_point	= gomiPluginTable_get_first_data_point;
	iinfo->get_next_data_point	= gomiPluginTable_get_next_data_point;
	iinfo->free_loop_context_at_end	= gomiPluginTable_free_loop_context;
	iinfo->table_reginfo		= table_info;
    
	return netsnmp_register_table_iterator (reg, iinfo);

error:
	if (table_info && table_info->indexes)		/* table_data_free_func() is internal */
		snmp_free_var (table_info->indexes);
	SNMP_FREE (table_info);
	SNMP_FREE (iinfo);
	netsnmp_handler_registration_free (reg);
	return -1;
}

/* Example iterator hook routines - using 'get_next' to do most of the work */
static 
netsnmp_variable_list*
gomiPluginTable_get_first_data_point (
	void**			my_loop_context,	/* valid through one query of multiple "data points" */
	void**			my_data_context,	/* answer blob which is passed to handler() */
	netsnmp_variable_list*	put_index_data,		/* answer */
	netsnmp_iterator_info*	mydata			/* iinfo on init() */
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != my_data_context);
	assert (nullptr != put_index_data);
	assert (nullptr != mydata);

	DLOG(INFO) << "gomiPluginTable_get_first_data_point()";

/* Create our own context for this SNMP loop, lock on list follows lifetime of context */
	std::shared_ptr<snmp_context_t> context (new snmp_context_t (gomi::gomi_t::global_list_lock_, gomi::gomi_t::global_list_));
	if (!(bool)context || context->gomi_list.empty()) {
		DLOG(INFO) << "No instances";
		return nullptr;
	}

/* Save context with NET-SNMP iterator. */
	*my_loop_context = context.get();
	snmp_context_t::global_list.push_back (std::move (context));

/* pass on for generic row access */
	return gomiPluginTable_get_next_data_point (my_loop_context, my_data_context, put_index_data,  mydata);
}

static
netsnmp_variable_list*
gomiPluginTable_get_next_data_point (
	void**			my_loop_context,
	void**			my_data_context,
	netsnmp_variable_list*	put_index_data,
	netsnmp_iterator_info*	mydata
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != my_data_context);
	assert (nullptr != put_index_data);
	assert (nullptr != mydata);

	DLOG(INFO) << "gomiPluginTable_get_next_data_point()";

	snmp_context_t* context = static_cast<snmp_context_t*>(*my_loop_context);
	netsnmp_variable_list *idx = put_index_data;

/* end of data points */
	if (context->gomi_it == context->gomi_list.end()) {
		DLOG(INFO) << "End of plugin instances.";
		return nullptr;
	}

/* this plugin instance as a data point */
	const gomi::gomi_t* gomi = *context->gomi_it++;

/* gomiPluginId */
	snmp_set_var_typed_value (idx, ASN_OCTET_STR, (const u_char*)gomi->plugin_id_.c_str(), gomi->plugin_id_.length());
        idx = idx->next_variable;

/* reference remains in list */
        *my_data_context = (void*)gomi;
        return put_index_data;
}

static
void
gomiPluginTable_free_loop_context (
	void*			my_loop_context,
	netsnmp_iterator_info*	mydata
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != mydata);

	DLOG(INFO) << "gomiPluginTable_free_loop_context()";

/* delete context and shared lock on global list of all gomi objects */
	snmp_context_t* context = static_cast<snmp_context_t*>(my_loop_context);
/* I'm sure there must be a better method :-( */
	snmp_context_t::global_list.erase (std::remove_if (snmp_context_t::global_list.begin(),
		snmp_context_t::global_list.end(),
		[context](std::shared_ptr<snmp_context_t>& shared_context) -> bool {
			return shared_context.get() == context;
	}));
}

/* handles requests for the gomiPluginTable table
 */
static
int
gomiPluginTable_handler (
	netsnmp_mib_handler*		handler,
	netsnmp_handler_registration*	reginfo,
	netsnmp_agent_request_info*	reqinfo,
	netsnmp_request_info*		requests
	)
{
	assert (nullptr != handler);
	assert (nullptr != reginfo);
	assert (nullptr != reqinfo);
	assert (nullptr != requests);

	DLOG(INFO) << "gomiPluginTable_handler()";

	switch (reqinfo->mode) {

/* Read-support (also covers GetNext requests) */

	case MODE_GET:
		for (netsnmp_request_info* request = requests;
		     request;
		     request = request->next)
		{
			const gomi::gomi_t* gomi = static_cast<gomi::gomi_t*>(netsnmp_extract_iterator_context (request));
			if (nullptr == gomi) {
				netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
				continue;
			}

			netsnmp_variable_list* var = request->requestvb;
			netsnmp_table_request_info* table_info = netsnmp_extract_table_info (request);
			if (nullptr == table_info) {
				snmp_log (__netsnmp_LOG_ERR, "gomiPluginTable_handler: empty table request info.\n");
				continue;
			}
    
			switch (table_info->colnum) {
						
			case COLUMN_GOMIPLUGINWINDOWSREGISTRYKEY:
				snmp_set_var_typed_value (var, ASN_OCTET_STR,
					(const u_char*)gomi->config_.key.c_str(), gomi->config_.key.length());
				break;

			case COLUMN_GOMIPLUGINSERVICENAME:
				snmp_set_var_typed_value (var, ASN_OCTET_STR,
					(const u_char*)gomi->config_.service_name.c_str(), gomi->config_.service_name.length());
				break;

			case COLUMN_GOMIPLUGINMONITORNAME:
				snmp_set_var_typed_value (var, ASN_OCTET_STR,
					(const u_char*)gomi->config_.monitor_name.c_str(), gomi->config_.monitor_name.length());
				break;

			case COLUMN_GOMIPLUGINEVENTQUEUENAME:
				snmp_set_var_typed_value (var, ASN_OCTET_STR,
					(const u_char*)gomi->config_.event_queue_name.c_str(), gomi->config_.event_queue_name.length());
				break;

			case COLUMN_GOMIPLUGINVENDORNAME:
				snmp_set_var_typed_value (var, ASN_OCTET_STR,
					(const u_char*)gomi->config_.vendor_name.c_str(), gomi->config_.vendor_name.length());
				break;

			case COLUMN_GOMIPLUGINMAXIMUMDATASIZE:
				{
					const unsigned maximum_data_size = (unsigned)gomi->config_.maximum_data_size;
					snmp_set_var_typed_value (var, ASN_UNSIGNED,
						(const u_char*)&maximum_data_size, sizeof (maximum_data_size));
				}
				break;

			case COLUMN_GOMIPLUGINSESSIONCAPACITY:
				{
					const unsigned session_capacity = (unsigned)gomi->config_.sessions[0].session_capacity;
					snmp_set_var_typed_value (var, ASN_UNSIGNED,
						(const u_char*)&session_capacity, sizeof (session_capacity));
				}
				break;

			case COLUMN_GOMIPLUGINWORKERCOUNT:
				{
					const unsigned worker_count = (unsigned)gomi->config_.worker_count;
					snmp_set_var_typed_value (var, ASN_UNSIGNED,
						(const u_char*)&worker_count, sizeof (worker_count));
				}
				break;

			case COLUMN_GOMIPLUGINRICSUFFIX:
				snmp_set_var_typed_value (var, ASN_OCTET_STR,
					(const u_char*)gomi->config_.suffix.c_str(), gomi->config_.suffix.length());
				break;

			case COLUMN_GOMIPLUGINDEFAULTTIMEZONE:
				snmp_set_var_typed_value (var, ASN_OCTET_STR,
					(const u_char*)gomi->config_.tz.c_str(), gomi->config_.tz.length());
				break;

			case COLUMN_GOMIPLUGINTIMEZONEDATABASE:
				snmp_set_var_typed_value (var, ASN_OCTET_STR,
					(const u_char*)gomi->config_.tzdb.c_str(), gomi->config_.tzdb.length());
				break;

			case COLUMN_GOMIPLUGINDEFAULTDAYCOUNT:
				{
					const unsigned day_count = (unsigned)gomi->config_.day_count;
					snmp_set_var_typed_value (var, ASN_UNSIGNED,
						(const u_char*)&day_count, sizeof (day_count));
				}
				break;

			default:
				snmp_log (__netsnmp_LOG_ERR, "gomiPluginTable_handler: unknown column.\n");
				netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHOBJECT);
				break;
			}
		}
		break;

	default:
		snmp_log (__netsnmp_LOG_ERR, "gomiPluginTable_handler: unnsupported mode.\n");
		break;
	}
	return SNMP_ERR_NOERROR;
}

/* Initialize the gomiPerformanceTable table by defining its contents and how it's structured
*/
static
int
initialize_table_gomiPerformanceTable(void)
{
	DLOG(INFO) << "initialize_table_gomiPerformanceTable()";

	static const oid gomiPerformanceTable_oid[] = {1,3,6,1,4,1,67,3,2,4};
	const size_t gomiPerformanceTable_oid_len = OID_LENGTH(gomiPerformanceTable_oid);
	netsnmp_handler_registration* reg = nullptr;
	netsnmp_iterator_info* iinfo = nullptr;
	netsnmp_table_registration_info* table_info = nullptr;

	reg = netsnmp_create_handler_registration (
		"gomiPerformanceTable",   gomiPerformanceTable_handler,
		gomiPerformanceTable_oid, gomiPerformanceTable_oid_len,
		HANDLER_CAN_RONLY
		);
	if (nullptr == reg)
		goto error;

	table_info = SNMP_MALLOC_TYPEDEF (netsnmp_table_registration_info);
	if (nullptr == table_info)
		goto error;
	netsnmp_table_helper_add_indexes (table_info,
					  ASN_OCTET_STR,  /* index: gomiPerformancePluginId */
					  0);
	table_info->min_column = COLUMN_GOMITCLQUERYRECEIVED;
	table_info->max_column = COLUMN_GOMILASTMSGSSENT;
    
	iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
	if (nullptr == iinfo)
		goto error;
	iinfo->get_first_data_point	= gomiPerformanceTable_get_first_data_point;
	iinfo->get_next_data_point	= gomiPerformanceTable_get_next_data_point;
	iinfo->free_loop_context_at_end = gomiPerformanceTable_free_loop_context;
	iinfo->table_reginfo		= table_info;
    
	return netsnmp_register_table_iterator (reg, iinfo);

error:
	if (table_info && table_info->indexes)		/* table_data_free_func() is internal */
		snmp_free_var (table_info->indexes);
	SNMP_FREE (table_info);
	SNMP_FREE (iinfo);
	netsnmp_handler_registration_free (reg);
	return -1;
}

/* Example iterator hook routines - using 'get_next' to do most of the work
 */
static
netsnmp_variable_list*
gomiPerformanceTable_get_first_data_point (
	void**			my_loop_context,	/* valid through one query of multiple "data points" */
	void**			my_data_context,	/* answer blob which is passed to handler() */
	netsnmp_variable_list*	put_index_data,		/* answer */
	netsnmp_iterator_info*	mydata			/* iinfo on init() */
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != my_data_context);
	assert (nullptr != put_index_data);
	assert (nullptr != mydata);

	DLOG(INFO) << "gomiPerformanceTable_get_first_data_point()";

/* Create our own context for this SNMP loop, lock on list follows lifetime of context */
	std::shared_ptr<snmp_context_t> context (new snmp_context_t (gomi::gomi_t::global_list_lock_, gomi::gomi_t::global_list_));
	if (!(bool)context || context->gomi_list.empty()) {
		DLOG(INFO) << "No instances";
		return nullptr;
	}

/* Save context with NET-SNMP iterator. */
	*my_loop_context = context.get();
	snmp_context_t::global_list.push_back (std::move (context));

/* pass on for generic row access */
	return gomiPerformanceTable_get_next_data_point(my_loop_context, my_data_context, put_index_data, mydata);
}

static
netsnmp_variable_list*
gomiPerformanceTable_get_next_data_point (
	void**			my_loop_context,
	void**			my_data_context,
	netsnmp_variable_list*	put_index_data,
	netsnmp_iterator_info*	mydata
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != my_data_context);
	assert (nullptr != put_index_data);
	assert (nullptr != mydata);

	DLOG(INFO) << "gomiPerformanceTable_get_next_data_point()";

	snmp_context_t* context = static_cast<snmp_context_t*>(*my_loop_context);
	netsnmp_variable_list *idx = put_index_data;

/* end of data points */
	if (context->gomi_it == context->gomi_list.end()) {
		DLOG(INFO) << "End of instances.";
		return nullptr;
	}

/* this plugin instance as a data point */
	const gomi::gomi_t* gomi = *context->gomi_it++;

/* gomiPerformancePluginId */
	snmp_set_var_typed_value (idx, ASN_OCTET_STR, (const u_char*)gomi->plugin_id_.c_str(), gomi->plugin_id_.length());
        idx = idx->next_variable;

/* reference remains in list */
        *my_data_context = (void*)gomi;
	return put_index_data;
}

static
void
gomiPerformanceTable_free_loop_context (
	void*			my_loop_context,
	netsnmp_iterator_info*	mydata
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != mydata);

	DLOG(INFO) << "gomiPerformanceTable_free_loop_context()";

/* delete context and shared lock on global list of all gomi objects */
	snmp_context_t* context = static_cast<snmp_context_t*>(my_loop_context);
/* I'm sure there must be a better method :-( */
	snmp_context_t::global_list.erase (std::remove_if (snmp_context_t::global_list.begin(),
		snmp_context_t::global_list.end(),
		[context](std::shared_ptr<snmp_context_t>& shared_context) -> bool {
			return shared_context.get() == context;
	}));
}

/* handles requests for the gomiPerformanceTable table
 */
static
int
gomiPerformanceTable_handler (
	netsnmp_mib_handler*		handler,
	netsnmp_handler_registration*	reginfo,
	netsnmp_agent_request_info*	reqinfo,
	netsnmp_request_info*		requests
	)
{
	assert (nullptr != handler);
	assert (nullptr != reginfo);
	assert (nullptr != reqinfo);
	assert (nullptr != requests);

	DLOG(INFO) << "gomiPerformanceTable_handler()";

	switch (reqinfo->mode) {
        
/* Read-support (also covers GetNext requests) */

	case MODE_GET:
		for (netsnmp_request_info* request = requests;
		     request;
		     request = request->next)
		{
			const gomi::gomi_t* gomi = static_cast<gomi::gomi_t*>(netsnmp_extract_iterator_context (request));
			if (nullptr == gomi) {
				netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
				continue;
			}

			netsnmp_variable_list* var = request->requestvb;
			netsnmp_table_request_info* table_info  = netsnmp_extract_table_info (request);
			if (nullptr == table_info) {
				snmp_log (__netsnmp_LOG_ERR, "gomiPerformanceTable_handler: empty table request info.\n");
				continue;
			}
    
			switch (table_info->colnum) {

			case COLUMN_GOMITCLQUERYRECEIVED:
				{
					const unsigned tcl_query_received = gomi->cumulative_stats_[GOMI_PC_TCL_QUERY_RECEIVED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&tcl_query_received, sizeof (tcl_query_received));
				}
				break;

			case COLUMN_GOMITIMERQUERYRECEIVED:
				{
					const unsigned timer_query_received = gomi->cumulative_stats_[GOMI_PC_TIMER_QUERY_RECEIVED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&timer_query_received, sizeof (timer_query_received));
				}
				break;

			case COLUMN_GOMILASTACTIVITY:
				{
					union {
						uint32_t	uint_value;
						__time32_t	time32_t_value;
					} last_activity;
					last_activity.time32_t_value = (gomi->last_activity_ - kUnixEpoch).total_seconds();
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&last_activity.uint_value, sizeof (last_activity.uint_value));
				}
				break;

			case COLUMN_GOMITCLSVCTIMEMIN:
				{
/* conversion of 64-bit integer */
					unsigned min_svc_time = 0;
					if (!gomi->min_tcl_time_.is_special())
						min_svc_time = (unsigned)gomi->min_tcl_time_.total_milliseconds();
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&min_svc_time, sizeof (min_svc_time));
				}
				break;

			case COLUMN_GOMITCLSVCTIMEMEAN:
				{
					unsigned mean_svc_time = 0;
					if (gomi->cumulative_stats_[GOMI_PC_TCL_QUERY_RECEIVED] > 0)
						mean_svc_time = (unsigned)(gomi->total_tcl_time_.total_milliseconds() / gomi->cumulative_stats_[GOMI_PC_TCL_QUERY_RECEIVED]);
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&mean_svc_time, sizeof (mean_svc_time));
				}
				break;

			case COLUMN_GOMITCLSVCTIMEMAX:
				{
					unsigned max_svc_time = 0;
					if (!gomi->max_tcl_time_.is_special())
						max_svc_time = (unsigned)gomi->max_tcl_time_.total_milliseconds();
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&max_svc_time, sizeof (max_svc_time));
				}
				break;

			case COLUMN_GOMITIMERSVCTIMEMIN:
				{
					unsigned min_svc_time = 0;
					if (!gomi->min_refresh_time_.is_special())
						min_svc_time = (unsigned)gomi->min_refresh_time_.total_milliseconds();
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&min_svc_time, sizeof (min_svc_time));
				}
				break;

			case COLUMN_GOMITIMERSVCTIMEMEAN:
				{
					unsigned mean_svc_time = 0;
					if (gomi->cumulative_stats_[GOMI_PC_TIMER_QUERY_RECEIVED] > 0)
						mean_svc_time = (unsigned)(gomi->total_refresh_time_.total_milliseconds() / gomi->cumulative_stats_[GOMI_PC_TIMER_QUERY_RECEIVED]);
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&mean_svc_time, sizeof (mean_svc_time));
				}
				break;

			case COLUMN_GOMITIMERSVCTIMEMAX:
				{
					unsigned max_svc_time = 0;
					if (!gomi->max_refresh_time_.is_special())
						max_svc_time = (unsigned)gomi->max_refresh_time_.total_milliseconds();
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&max_svc_time, sizeof (max_svc_time));
				}
				break;

			case COLUMN_GOMIMSGSSENT:
				{
					const unsigned msg_sent = (bool)gomi->provider_ ? gomi->provider_->cumulative_stats_[PROVIDER_PC_MSGS_SENT] : 0;
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&msg_sent, sizeof (msg_sent));
				}
				break;

			case COLUMN_GOMILASTMSGSSENT:
				{
					union {
						uint32_t	uint_value;
						__time32_t	time32_t_value;
					} last_activity;
					last_activity.time32_t_value = (bool)gomi->provider_ ? ((gomi->provider_->last_activity_ - kUnixEpoch).total_seconds()) : 0;
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&last_activity.uint_value, sizeof (last_activity.uint_value));
				}
				break;

			default:
				snmp_log (__netsnmp_LOG_ERR, "gomiPerformanceTable_handler: unknown column.\n");
				netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHOBJECT);
				break;
			}
		}
		break;

	default:
		snmp_log (__netsnmp_LOG_ERR, "gomiPerformanceTable_handler: unsupported mode.\n");
		break;
    }

    return SNMP_ERR_NOERROR;
}

/* Initialize the gomiClientTable table by defining its contents and how it's structured.
 */
static
int
initialize_table_gomiClientTable(void)
{
	DLOG(INFO) << "initialize_table_gomiClientTable()";

	static const oid gomiClientTable_oid[] = {1,3,6,1,4,1,67,3,2,5};
	const size_t gomiClientTable_oid_len = OID_LENGTH (gomiClientTable_oid);
	netsnmp_handler_registration* reg = nullptr;
	netsnmp_iterator_info* iinfo = nullptr;
	netsnmp_table_registration_info* table_info = nullptr;

	reg = netsnmp_create_handler_registration (
		"gomiClientTable",	gomiClientTable_handler,
		gomiClientTable_oid,	gomiClientTable_oid_len,
		HANDLER_CAN_RONLY
		);
	if (nullptr == reg)
		goto error;

	table_info = SNMP_MALLOC_TYPEDEF (netsnmp_table_registration_info);
	if (nullptr == table_info)
		goto error;
	netsnmp_table_helper_add_indexes (table_info,
					  ASN_OCTET_STR,  /* index: gomiClientPluginId */
					  ASN_OCTET_STR,  /* index: gomiClientHandle */
					  0);
	table_info->min_column = COLUMN_GOMICLIENTLOGINNAME;
	table_info->max_column = COLUMN_GOMICLIENTPUBLISHERNAME;
    
	iinfo = SNMP_MALLOC_TYPEDEF (netsnmp_iterator_info);
	if (nullptr == iinfo)
		goto error;
	iinfo->get_first_data_point	= gomiClientTable_get_first_data_point;
	iinfo->get_next_data_point	= gomiClientTable_get_next_data_point;
	iinfo->free_loop_context_at_end	= gomiClientTable_free_loop_context;
	iinfo->table_reginfo		= table_info;
    
	return netsnmp_register_table_iterator (reg, iinfo);

error:
	if (table_info && table_info->indexes)		/* table_data_free_func() is internal */
		snmp_free_var (table_info->indexes);
	SNMP_FREE (table_info);
	SNMP_FREE (iinfo);
	netsnmp_handler_registration_free (reg);
	return -1;
}

/* Example iterator hook routines - using 'get_next' to do most of the work */
static 
netsnmp_variable_list*
gomiClientTable_get_first_data_point (
	void**			my_loop_context,	/* valid through one query of multiple "data points" */
	void**			my_data_context,	/* answer blob which is passed to handler() */
	netsnmp_variable_list*	put_index_data,		/* answer */
	netsnmp_iterator_info*	mydata			/* iinfo on init() */
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != my_data_context);
	assert (nullptr != put_index_data);
	assert (nullptr != mydata);

	DLOG(INFO) << "gomiClientTable_get_first_data_point()";

/* Create our own context for this SNMP loop, lock on list follows lifetime of context. */
	std::shared_ptr<snmp_context_t> context (new snmp_context_t (gomi::gomi_t::global_list_lock_, gomi::gomi_t::global_list_));
	if (!(bool)context || context->gomi_list.empty()) {
		DLOG(INFO) << "No plugin instances.";
		return nullptr;
	}

/* Find first node, through all plugin instances. */
	for (context->gomi_it = context->gomi_list.begin();
		context->gomi_it != context->gomi_list.end();
		++(context->gomi_it))
	{
		boost::shared_lock<boost::shared_mutex> lock ((*context->gomi_it)->provider_->clients_lock_);
/* and through all sessions for each plugin provider. */
		context->client_it = (*context->gomi_it)->provider_->clients_.begin();
		if (context->client_it != (*context->gomi_it)->provider_->clients_.end()) {
			context->clients_lock.swap (lock);
			break;
		}
	}

/* no node found. */
	if (context->gomi_it == context->gomi_list.end() ||
	    context->client_it == (*context->gomi_it)->provider_->clients_.end()) {
		DLOG(INFO) << "No client session instances.";
		return nullptr;
	}

/* Save context with NET-SNMP iterator. */
	*my_loop_context = context.get();
	snmp_context_t::global_list.push_back (std::move (context));

/* pass on for generic row access */
	return gomiClientTable_get_next_data_point (my_loop_context, my_data_context, put_index_data,  mydata);
}

static
netsnmp_variable_list*
gomiClientTable_get_next_data_point (
	void**			my_loop_context,
	void**			my_data_context,
	netsnmp_variable_list*	put_index_data,
	netsnmp_iterator_info*	mydata
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != my_data_context);
	assert (nullptr != put_index_data);
	assert (nullptr != mydata);

	DLOG(INFO) << "gomiClientTable_get_next_data_point()";

	snmp_context_t* context = static_cast<snmp_context_t*>(*my_loop_context);
	netsnmp_variable_list *idx = put_index_data;

/* end of data points */
	if (context->gomi_it == context->gomi_list.end()) {
		DLOG(INFO) << "End of plugin instances.";
		return nullptr;
	}
	if (context->client_it == (*context->gomi_it)->provider_->clients_.end()) {
		DLOG(INFO) << "End of client session instances.";
		return nullptr;
	}

/* this session instance as a data point */
	const gomi::client_t* client = (context->client_it->second).get();
	const gomi::gomi_t* gomi = *context->gomi_it;

/* gomiClientPluginId */
	snmp_set_var_typed_value (idx, ASN_OCTET_STR, (const u_char*)gomi->plugin_id_.c_str(), gomi->plugin_id_.length());
        idx = idx->next_variable;

/* gomiClientHandle */
	snmp_set_var_typed_value (idx, ASN_OCTET_STR, (const u_char*)client->prefix_.c_str(), client->prefix_.length() - 1);

/* hunt for next valid node */
	while (++(context->client_it) == (*context->gomi_it)->provider_->clients_.end()) {
		context->clients_lock.unlock ();
		if (++(context->gomi_it) == context->gomi_list.end()) {
			break;
		}
		boost::shared_lock<boost::shared_mutex> lock ((*context->gomi_it)->provider_->clients_lock_);
		context->clients_lock.swap (lock);
		context->client_it = (*context->gomi_it)->provider_->clients_.begin();
	}

/* reference remains in list */
        *my_data_context = (void*)client;
        return put_index_data;
}

static
void
gomiClientTable_free_loop_context (
	void*			my_loop_context,
	netsnmp_iterator_info*	mydata
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != mydata);

	DLOG(INFO) << "gomiClientTable_free_loop_context ()";

/* delete context and shared lock on global list of all gomi objects */
	snmp_context_t* context = static_cast<snmp_context_t*>(my_loop_context);
/* I'm sure there must be a better method :-( */
	snmp_context_t::global_list.erase (std::remove_if (snmp_context_t::global_list.begin(),
		snmp_context_t::global_list.end(),
		[context](std::shared_ptr<snmp_context_t>& shared_context) -> bool {
			return shared_context.get() == context;
	}));
}

/* handles requests for the gomiPluginTable table
 */
static
int
gomiClientTable_handler (
	netsnmp_mib_handler*		handler,
	netsnmp_handler_registration*	reginfo,
	netsnmp_agent_request_info*	reqinfo,
	netsnmp_request_info*		requests
	)
{
	assert (nullptr != handler);
	assert (nullptr != reginfo);
	assert (nullptr != reqinfo);
	assert (nullptr != requests);

	DLOG(INFO) << "gomiClientTable_handler()";

	switch (reqinfo->mode) {

/* Read-support (also covers GetNext requests) */

	case MODE_GET:
		for (netsnmp_request_info* request = requests;
		     request;
		     request = request->next)
		{
			const gomi::client_t* client = reinterpret_cast<gomi::client_t*>(netsnmp_extract_iterator_context (request));
			if (nullptr == client) {
				netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
				continue;
			}

			netsnmp_variable_list* var = request->requestvb;
			netsnmp_table_request_info* table_info = netsnmp_extract_table_info (request);
			if (nullptr == table_info) {
				snmp_log (__netsnmp_LOG_ERR, "gomiClientTable_handler: empty table request info.\n");
				continue;
			}

			const auto& config = client->provider_->config_;
			switch (table_info->colnum) {
						
			case COLUMN_GOMICLIENTLOGINNAME:
				snmp_set_var_typed_value (var, ASN_OCTET_STR,
					(const u_char*)client->name_.c_str(), client->name_.length());
				break;

			case COLUMN_GOMICLIENTIPADDRESS:
				snmp_set_var_typed_value (var, ASN_OCTET_STR,
					(const u_char*)client->address_.c_str(), client->address_.length());
				break;

			case COLUMN_GOMICLIENTRSSLPORT:
				snmp_set_var_typed_value (var, ASN_OCTET_STR,
					(const u_char*)config.sessions[0].rssl_port.c_str(), config.sessions[0].rssl_port.length());
				break;

			case COLUMN_GOMICLIENTSESSIONNAME:
				snmp_set_var_typed_value (var, ASN_OCTET_STR,
					(const u_char*)config.sessions[0].session_name.c_str(), config.sessions[0].session_name.length());
				break;

			case COLUMN_GOMICLIENTCONNECTIONNAME:
				snmp_set_var_typed_value (var, ASN_OCTET_STR,
					(const u_char*)config.sessions[0].connection_name.c_str(), config.sessions[0].connection_name.length());
				break;

			case COLUMN_GOMICLIENTPUBLISHERNAME:
				snmp_set_var_typed_value (var, ASN_OCTET_STR,
					(const u_char*)config.sessions[0].publisher_name.c_str(), config.sessions[0].publisher_name.length());
				break;

			default:
				snmp_log (__netsnmp_LOG_ERR, "gomiClientTable_handler: unknown column.\n");
				netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHOBJECT);
				break;
			}
		}
		break;

	default:
		snmp_log (__netsnmp_LOG_ERR, "gomiClientTable_handler: unnsupported mode.\n");
		break;
	}
	return SNMP_ERR_NOERROR;
}

/* Initialize the gomiClientPerformanceTable table by defining its contents and how it's structured
*/
static
int
initialize_table_gomiClientPerformanceTable(void)
{
	DLOG(INFO) << "initialize_table_gomiClientPerformanceTable()";

	static const oid gomiClientPerformanceTable_oid[] = {1,3,6,1,4,1,67,3,2,6};
	const size_t gomiClientPerformanceTable_oid_len = OID_LENGTH(gomiClientPerformanceTable_oid);
	netsnmp_handler_registration* reg = nullptr;
	netsnmp_iterator_info* iinfo = nullptr;
	netsnmp_table_registration_info* table_info = nullptr;

	reg = netsnmp_create_handler_registration (
		"gomiClientPerformanceTable",   gomiClientPerformanceTable_handler,
		gomiClientPerformanceTable_oid, gomiClientPerformanceTable_oid_len,
		HANDLER_CAN_RONLY
		);
	if (nullptr == reg)
		goto error;

	table_info = SNMP_MALLOC_TYPEDEF (netsnmp_table_registration_info);
	if (nullptr == table_info)
		goto error;
	netsnmp_table_helper_add_indexes (table_info,
					  ASN_OCTET_STR,  /* index: gomiClientPerformancePluginId */
					  ASN_OCTET_STR,  /* index: gomiClientPerformanceHandle */
					  0);
	table_info->min_column = COLUMN_GOMICLIENTLASTACTIVITY;
	table_info->max_column = COLUMN_GOMIOMMINACTIVECLIENTSESSIONEXCEPTION;
    
	iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
	if (nullptr == iinfo)
		goto error;
	iinfo->get_first_data_point	= gomiClientPerformanceTable_get_first_data_point;
	iinfo->get_next_data_point	= gomiClientPerformanceTable_get_next_data_point;
	iinfo->free_loop_context_at_end = gomiClientPerformanceTable_free_loop_context;
	iinfo->table_reginfo		= table_info;
    
	return netsnmp_register_table_iterator (reg, iinfo);

error:
	if (table_info && table_info->indexes)		/* table_data_free_func() is internal */
		snmp_free_var (table_info->indexes);
	SNMP_FREE (table_info);
	SNMP_FREE (iinfo);
	netsnmp_handler_registration_free (reg);
	return -1;
}

/* Example iterator hook routines - using 'get_next' to do most of the work
 */
static
netsnmp_variable_list*
gomiClientPerformanceTable_get_first_data_point (
	void**			my_loop_context,	/* valid through one query of multiple "data points" */
	void**			my_data_context,	/* answer blob which is passed to handler() */
	netsnmp_variable_list*	put_index_data,		/* answer */
	netsnmp_iterator_info*	mydata			/* iinfo on init() */
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != my_data_context);
	assert (nullptr != put_index_data);
	assert (nullptr != mydata);

	DLOG(INFO) << "gomiClientPerformanceTable_get_first_data_point()";

/* Create our own context for this SNMP loop, lock on list follows lifetime of context */
	std::shared_ptr<snmp_context_t> context (new snmp_context_t (gomi::gomi_t::global_list_lock_, gomi::gomi_t::global_list_));
	if (!(bool)context || context->gomi_list.empty()) {
		DLOG(INFO) << "No plugin instances";
		return nullptr;
	}

/* Find first node, through all plugin instances. */
	for (context->gomi_it = context->gomi_list.begin();
		context->gomi_it != context->gomi_list.end();
		++(context->gomi_it))
	{
		boost::shared_lock<boost::shared_mutex> lock ((*context->gomi_it)->provider_->clients_lock_);
/* and through all sessions for each plugin provider. */
		context->client_it = (*context->gomi_it)->provider_->clients_.begin();
		if (context->client_it != (*context->gomi_it)->provider_->clients_.end()) {
			context->clients_lock.swap (lock);
			break;
		}
	}

/* no node found. */
	if (context->gomi_it == context->gomi_list.end() ||
	    context->client_it == (*context->gomi_it)->provider_->clients_.end()) {
		DLOG(INFO) << "No client session instances.";
		return nullptr;
	}

/* Save context with NET-SNMP iterator. */
	*my_loop_context = context.get();
	snmp_context_t::global_list.push_back (std::move (context));

/* pass on for generic row access */
	return gomiClientPerformanceTable_get_next_data_point(my_loop_context, my_data_context, put_index_data, mydata);
}

static
netsnmp_variable_list*
gomiClientPerformanceTable_get_next_data_point (
	void**			my_loop_context,
	void**			my_data_context,
	netsnmp_variable_list*	put_index_data,
	netsnmp_iterator_info*	mydata
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != my_data_context);
	assert (nullptr != put_index_data);
	assert (nullptr != mydata);

	DLOG(INFO) << "gomiClientPerformanceTable_get_next_data_point()";

	snmp_context_t* context = static_cast<snmp_context_t*>(*my_loop_context);
	netsnmp_variable_list *idx = put_index_data;

/* end of data points */
	if (context->gomi_it == context->gomi_list.end()) {
		DLOG(INFO) << "End of plugin instances.";
		return nullptr;
	}
	if (context->client_it == (*context->gomi_it)->provider_->clients_.end()) {
		DLOG(INFO) << "End of client session instances.";
		return nullptr;
	}

/* this plugin instance as a data point */
	const gomi::client_t* client = (context->client_it->second).get();
	const gomi::gomi_t* gomi = *context->gomi_it;

/* gomiClientPerformancePluginId */
	snmp_set_var_typed_value (idx, ASN_OCTET_STR, (const u_char*)gomi->plugin_id_.c_str(), gomi->plugin_id_.length());
        idx = idx->next_variable;

/* gomiClientPerformanceHandle */
	snmp_set_var_typed_value (idx, ASN_OCTET_STR, (const u_char*)client->prefix_.c_str(), client->prefix_.length() - 1);

/* hunt for next valid node */
	while (++(context->client_it) == (*context->gomi_it)->provider_->clients_.end()) {
		context->clients_lock.unlock ();
		if (++(context->gomi_it) == context->gomi_list.end()) {
			break;
		}
		boost::shared_lock<boost::shared_mutex> lock ((*context->gomi_it)->provider_->clients_lock_);
		context->clients_lock.swap (lock);
		context->client_it = (*context->gomi_it)->provider_->clients_.begin();
	}

/* reference remains in list */
        *my_data_context = (void*)client;
	return put_index_data;
}

static
void
gomiClientPerformanceTable_free_loop_context (
	void*			my_loop_context,
	netsnmp_iterator_info*	mydata
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != mydata);

	DLOG(INFO) << "gomiClientPerformanceTable_free_loop_context()";

/* delete context and shared lock on global list of all gomi objects */
	snmp_context_t* context = static_cast<snmp_context_t*>(my_loop_context);
/* I'm sure there must be a better method :-( */
	snmp_context_t::global_list.erase (std::remove_if (snmp_context_t::global_list.begin(),
		snmp_context_t::global_list.end(),
		[context](std::shared_ptr<snmp_context_t>& shared_context) -> bool {
			return shared_context.get() == context;
	}));
}

/* handles requests for the gomiClientPerformanceTable table
 */
static
int
gomiClientPerformanceTable_handler (
	netsnmp_mib_handler*		handler,
	netsnmp_handler_registration*	reginfo,
	netsnmp_agent_request_info*	reqinfo,
	netsnmp_request_info*		requests
	)
{
	assert (nullptr != handler);
	assert (nullptr != reginfo);
	assert (nullptr != reqinfo);
	assert (nullptr != requests);

	DLOG(INFO) << "gomiClientPerformanceTable_handler()";

	switch (reqinfo->mode) {
        
/* Read-support (also covers GetNext requests) */

	case MODE_GET:
		for (netsnmp_request_info* request = requests;
		     request;
		     request = request->next)
		{
			const gomi::client_t* client = static_cast<gomi::client_t*>(netsnmp_extract_iterator_context (request));
			if (nullptr == client) {
				netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
				continue;
			}

			netsnmp_variable_list* var = request->requestvb;
			netsnmp_table_request_info* table_info  = netsnmp_extract_table_info (request);
			if (nullptr == table_info) {
				snmp_log (__netsnmp_LOG_ERR, "gomiClientPerformanceTable_handler: empty table request info.\n");
				continue;
			}
    
			switch (table_info->colnum) {

			case COLUMN_GOMICLIENTLASTACTIVITY:
				{
					union {
						uint32_t	uint_value;
						__time32_t	time32_t_value;
					} last_activity;
					last_activity.time32_t_value = (client->last_activity_ - kUnixEpoch).total_seconds();
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&last_activity.uint_value, sizeof (last_activity.uint_value));
				}
				break;

			case COLUMN_GOMICLIENTRFAMSGSSENT:
				{
					const unsigned rfa_msg_sent = client->cumulative_stats_[CLIENT_PC_RFA_MSGS_SENT];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&rfa_msg_sent, sizeof (rfa_msg_sent));
				}
				break;

			case COLUMN_GOMIRFAEVENTSRECEIVED:
				{
					const unsigned rfa_events_received = client->cumulative_stats_[CLIENT_PC_RFA_EVENTS_RECEIVED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&rfa_events_received, sizeof (rfa_events_received));
				}
				break;

			case COLUMN_GOMIRFAEVENTSDISCARDED:
				{
					const unsigned rfa_events_discarded = client->cumulative_stats_[CLIENT_PC_RFA_EVENTS_DISCARDED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&rfa_events_discarded, sizeof (rfa_events_discarded));
				}
				break;
            
			case COLUMN_GOMIOMMSOLICITEDITEMEVENTSRECEIVED:
				{
					const unsigned omm_item_events_received = client->cumulative_stats_[CLIENT_PC_OMM_SOLICITED_ITEM_EVENTS_RECEIVED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&omm_item_events_received, sizeof (omm_item_events_received));
				}
				break;

			case COLUMN_GOMIOMMSOLICITEDITEMEVENTSDISCARDED:
				{
					const unsigned omm_item_events_discarded = client->cumulative_stats_[CLIENT_PC_OMM_SOLICITED_ITEM_EVENTS_DISCARDED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&omm_item_events_discarded, sizeof (omm_item_events_discarded));
				}
				break;

			case COLUMN_GOMIREQUESTMSGSRECEIVED:
				{
					const unsigned response_msgs_received = client->cumulative_stats_[CLIENT_PC_REQUEST_MSGS_RECEIVED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&response_msgs_received, sizeof (response_msgs_received));
				}
				break;

			case COLUMN_GOMIREQUESTMSGSDISCARDED:
				{
					const unsigned response_msgs_discarded = client->cumulative_stats_[CLIENT_PC_REQUEST_MSGS_DISCARDED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&response_msgs_discarded, sizeof (response_msgs_discarded));
				}
				break;

			case COLUMN_GOMIMMTLOGINRECEIVED:
				{
					const unsigned login_received = client->cumulative_stats_[CLIENT_PC_MMT_LOGIN_RECEIVED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&login_received, sizeof (login_received));
				}
				break;

			case COLUMN_GOMIMMTLOGINVALIDATED:
				{
					const unsigned login_validated = client->cumulative_stats_[CLIENT_PC_MMT_LOGIN_VALIDATED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&login_validated, sizeof (login_validated));
				}
				break;

			case COLUMN_GOMIMMTLOGINMALFORMED:
				{
					const unsigned login_malformed = client->cumulative_stats_[CLIENT_PC_MMT_LOGIN_MALFORMED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&login_malformed, sizeof (login_malformed));
				}
				break;

			case COLUMN_GOMIMMTLOGINREJECTED:
				{
					const unsigned login_rejected = client->cumulative_stats_[CLIENT_PC_MMT_LOGIN_REJECTED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&login_rejected, sizeof (login_rejected));
				}
				break;

			case COLUMN_GOMIMMTLOGINACCEPTED:
				{
					const unsigned login_accepted = client->cumulative_stats_[CLIENT_PC_MMT_LOGIN_ACCEPTED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&login_accepted, sizeof (login_accepted));
				}
				break;

			case COLUMN_GOMIMMTLOGINRESPONSEVALIDATED:
				{
					const unsigned response_validated = client->cumulative_stats_[CLIENT_PC_MMT_LOGIN_RESPONSE_VALIDATED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&response_validated, sizeof (response_validated));
				}
				break;

			case COLUMN_GOMIMMTLOGINRESPONSEMALFORMED:
				{
					const unsigned response_malformed = client->cumulative_stats_[CLIENT_PC_MMT_LOGIN_RESPONSE_MALFORMED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&response_malformed, sizeof (response_malformed));
				}
				break;

			case COLUMN_GOMIMMTLOGINEXCEPTION:
				{
					const unsigned exception_count = client->cumulative_stats_[CLIENT_PC_MMT_LOGIN_EXCEPTION];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&exception_count, sizeof (exception_count));
				}
				break;

			case COLUMN_GOMIMMTDIRECTORYREQUESTRECEIVED:
				{
					const unsigned request_received = client->cumulative_stats_[CLIENT_PC_MMT_DIRECTORY_REQUEST_RECEIVED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&request_received, sizeof (request_received));
				}
				break;

			case COLUMN_GOMIMMTDIRECTORYREQUESTVALIDATED:
				{
					const unsigned request_validated = client->cumulative_stats_[CLIENT_PC_MMT_DIRECTORY_REQUEST_VALIDATED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&request_validated, sizeof (request_validated));
				}
				break;

			case COLUMN_GOMIMMTDIRECTORYREQUESTMALFORMED:
				{
					const unsigned request_malformed = client->cumulative_stats_[CLIENT_PC_MMT_DIRECTORY_REQUEST_MALFORMED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&request_malformed, sizeof (request_malformed));
				}
				break;

			case COLUMN_GOMIMMTDIRECTORYVALIDATED:
				{
					const unsigned directory_validated = client->cumulative_stats_[CLIENT_PC_MMT_DIRECTORY_VALIDATED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&directory_validated, sizeof (directory_validated));
				}
				break;

			case COLUMN_GOMIMMTDIRECTORYMALFORMED:
				{
					const unsigned directory_malformed = client->cumulative_stats_[CLIENT_PC_MMT_DIRECTORY_MALFORMED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&directory_malformed, sizeof (directory_malformed));
				}
				break;

			case COLUMN_GOMIMMTDIRECTORYSENT:
				{
					const unsigned directory_sent = client->cumulative_stats_[CLIENT_PC_MMT_DIRECTORY_SENT];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&directory_sent, sizeof (directory_sent));
				}
				break;

			case COLUMN_GOMIMMTDIRECTORYEXCEPTION:
				{
					const unsigned exception_count = client->cumulative_stats_[CLIENT_PC_MMT_DIRECTORY_EXCEPTION];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&exception_count, sizeof (exception_count));
				}
				break;

			case COLUMN_GOMIMMTDICTIONARYREQUESTRECEIVED:
				{
					const unsigned request_received = client->cumulative_stats_[CLIENT_PC_MMT_DICTIONARY_REQUEST_RECEIVED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&request_received, sizeof (request_received));
				}
				break;

			case COLUMN_GOMIMMTDICTIONARYREQUESTVALIDATED:
				{
					const unsigned request_validated = client->cumulative_stats_[CLIENT_PC_MMT_DICTIONARY_REQUEST_VALIDATED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&request_validated, sizeof (request_validated));
				}
				break;

			case COLUMN_GOMIMMTDICTIONARYREQUESTMALFORMED:
				{
					const unsigned request_malformed = client->cumulative_stats_[CLIENT_PC_MMT_DICTIONARY_REQUEST_MALFORMED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&request_malformed, sizeof (request_malformed));
				}
				break;

			case COLUMN_GOMIITEMREQUESTRECEIVED:
				{
					const unsigned request_received = client->cumulative_stats_[CLIENT_PC_ITEM_REQUEST_RECEIVED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&request_received, sizeof (request_received));
				}
				break;

			case COLUMN_GOMIITEMREISSUEREQUESTRECEIVED:
				{
					const unsigned reissue_received = client->cumulative_stats_[CLIENT_PC_ITEM_REISSUE_REQUEST_RECEIVED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&reissue_received, sizeof (reissue_received));
				}
				break;

			case COLUMN_GOMIITEMCLOSEREQUESTRECEIVED:
				{
					const unsigned request_received = client->cumulative_stats_[CLIENT_PC_ITEM_CLOSE_REQUEST_RECEIVED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&request_received, sizeof (request_received));
				}
				break;

			case COLUMN_GOMIITEMREQUESTMALFORMED:
				{
					const unsigned request_malformed = client->cumulative_stats_[CLIENT_PC_ITEM_REQUEST_MALFORMED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&request_malformed, sizeof (request_malformed));
				}
				break;

			case COLUMN_GOMIITEMREQUESTBEFORELOGIN:
				{
					const unsigned noauth_request = client->cumulative_stats_[CLIENT_PC_ITEM_REQUEST_BEFORE_LOGIN];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&noauth_request, sizeof (noauth_request));
				}
				break;

			case COLUMN_GOMIITEMDUPLICATESNAPSHOT:
				{
					const unsigned duplicate_snap = client->cumulative_stats_[CLIENT_PC_ITEM_DUPLICATE_SNAPSHOT];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&duplicate_snap, sizeof (duplicate_snap));
				}
				break;

			case COLUMN_GOMIITEMREQUESTDISCARDED:
				{
					const unsigned request_discarded = client->cumulative_stats_[CLIENT_PC_ITEM_REQUEST_DISCARDED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&request_discarded, sizeof (request_discarded));
				}
				break;

			case COLUMN_GOMIITEMREQUESTREJECTED:
				{
					const unsigned request_rejected = client->cumulative_stats_[CLIENT_PC_ITEM_REQUEST_REJECTED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&request_rejected, sizeof (request_rejected));
				}
				break;

			case COLUMN_GOMIITEMVALIDATED:
				{
					const unsigned item_validated = client->cumulative_stats_[CLIENT_PC_ITEM_VALIDATED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&item_validated, sizeof (item_validated));
				}
				break;

			case COLUMN_GOMIITEMMALFORMED:
				{
					const unsigned item_malformed = client->cumulative_stats_[CLIENT_PC_ITEM_MALFORMED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&item_malformed, sizeof (item_malformed));
				}
				break;

			case COLUMN_GOMIITEMNOTFOUND:
				{
					const unsigned item_not_found = client->cumulative_stats_[CLIENT_PC_ITEM_NOT_FOUND];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&item_not_found, sizeof (item_not_found));
				}
				break;

			case COLUMN_GOMIITEMSENT:
				{
					const unsigned item_sent = client->cumulative_stats_[CLIENT_PC_ITEM_SENT];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&item_sent, sizeof (item_sent));
				}
				break;

			case COLUMN_GOMIITEMCLOSED:
				{
					const unsigned item_closed = client->cumulative_stats_[CLIENT_PC_ITEM_CLOSED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&item_closed, sizeof (item_closed));
				}
				break;

			case COLUMN_GOMIITEMEXCEPTION:
				{
					const unsigned exception_count = client->cumulative_stats_[CLIENT_PC_ITEM_EXCEPTION];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&exception_count, sizeof (exception_count));
				}
				break;

			case COLUMN_GOMIOMMINACTIVECLIENTSESSIONRECEIVED:
				{
					const unsigned inactive_sessions = client->cumulative_stats_[CLIENT_PC_OMM_INACTIVE_CLIENT_SESSION_RECEIVED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&inactive_sessions, sizeof (inactive_sessions));
				}
				break;

			case COLUMN_GOMIOMMINACTIVECLIENTSESSIONEXCEPTION:
				{
					const unsigned exception_count = client->cumulative_stats_[CLIENT_PC_OMM_INACTIVE_CLIENT_SESSION_EXCEPTION];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&exception_count, sizeof (exception_count));
				}
				break;

			default:
				snmp_log (__netsnmp_LOG_ERR, "gomiClientPerformanceTable_handler: unknown column.\n");
				netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHOBJECT);
				break;
			}
		}
		break;

	default:
		snmp_log (__netsnmp_LOG_ERR, "gomiClientPerformanceTable_handler: unsupported mode.\n");
		break;
    }

    return SNMP_ERR_NOERROR;
}

/* Initialize the gomiOutageMeasurementTable table by defining its contents and how it's structured
*/
static
int
initialize_table_gomiOutageMeasurementTable(void)
{
	DLOG(INFO) << "initialize_table_gomiOutageMeasurementTable()";

	static const oid gomiOutageMeasurementTable_oid[] = {1,3,6,1,4,1,67,3,2,7};
	const size_t gomiOutageMeasurementTable_oid_len = OID_LENGTH(gomiOutageMeasurementTable_oid);
	netsnmp_handler_registration* reg = nullptr;
	netsnmp_iterator_info* iinfo = nullptr;
	netsnmp_table_registration_info* table_info = nullptr;

	reg = netsnmp_create_handler_registration (
		"gomiOutageMeasurementTable",   gomiOutageMeasurementTable_handler,
		gomiOutageMeasurementTable_oid, gomiOutageMeasurementTable_oid_len,
		HANDLER_CAN_RONLY
		);
	if (nullptr == reg)
		goto error;

	table_info = SNMP_MALLOC_TYPEDEF (netsnmp_table_registration_info);
	if (nullptr == table_info)
		goto error;
	netsnmp_table_helper_add_indexes (table_info,
					  ASN_OCTET_STR,  /* index: gomiOutageMeasurementPluginId */
					  ASN_OCTET_STR,  /* index: gomiOutageMeasurementClientName */
					  0);
	table_info->min_column = COLUMN_GOMIACCUMULATEDOUTAGETIME;
	table_info->max_column = COLUMN_GOMIRECORDINGSTARTTIME;
    
	iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
	if (nullptr == iinfo)
		goto error;
	iinfo->get_first_data_point	= gomiOutageMeasurementTable_get_first_data_point;
	iinfo->get_next_data_point	= gomiOutageMeasurementTable_get_next_data_point;
	iinfo->free_loop_context_at_end = gomiOutageMeasurementTable_free_loop_context;
	iinfo->table_reginfo		= table_info;
    
	return netsnmp_register_table_iterator (reg, iinfo);

error:
	if (table_info && table_info->indexes)		/* table_data_free_func() is internal */
		snmp_free_var (table_info->indexes);
	SNMP_FREE (table_info);
	SNMP_FREE (iinfo);
	netsnmp_handler_registration_free (reg);
	return -1;
}

/* Example iterator hook routines - using 'get_next' to do most of the work
 */
static
netsnmp_variable_list*
gomiOutageMeasurementTable_get_first_data_point (
	void**			my_loop_context,	/* valid through one query of multiple "data points" */
	void**			my_data_context,	/* answer blob which is passed to handler() */
	netsnmp_variable_list*	put_index_data,		/* answer */
	netsnmp_iterator_info*	mydata			/* iinfo on init() */
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != my_data_context);
	assert (nullptr != put_index_data);
	assert (nullptr != mydata);

	DLOG(INFO) << "gomiOutageMeasurementTable_get_first_data_point()";

/* Create our own context for this SNMP loop, lock on list follows lifetime of context */
	std::shared_ptr<snmp_context_t> context (new snmp_context_t (gomi::gomi_t::global_list_lock_, gomi::gomi_t::global_list_));
	if (!(bool)context || context->gomi_list.empty()) {
		DLOG(INFO) << "No plugin instances";
		return nullptr;
	}

/* Find first node, through all plugin instances. */
	for (context->gomi_it = context->gomi_list.begin();
		context->gomi_it != context->gomi_list.end();
		++(context->gomi_it))
	{
/* and through all sessions for each plugin provider. */
		context->cool_it = (*context->gomi_it)->provider_->cool_.begin();
		if (context->cool_it != (*context->gomi_it)->provider_->cool_.end()) {
			break;
		}
	}

/* no node found. */
	if (context->gomi_it == context->gomi_list.end() ||
	    context->cool_it == (*context->gomi_it)->provider_->cool_.end()) {
		DLOG(INFO) << "No COOL instances.";
		return nullptr;
	}

/* Save context with NET-SNMP iterator. */
	*my_loop_context = context.get();
	snmp_context_t::global_list.push_back (std::move (context));

/* pass on for generic row access */
	return gomiOutageMeasurementTable_get_next_data_point(my_loop_context, my_data_context, put_index_data, mydata);
}

static
netsnmp_variable_list*
gomiOutageMeasurementTable_get_next_data_point (
	void**			my_loop_context,
	void**			my_data_context,
	netsnmp_variable_list*	put_index_data,
	netsnmp_iterator_info*	mydata
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != my_data_context);
	assert (nullptr != put_index_data);
	assert (nullptr != mydata);

	DLOG(INFO) << "gomiOutageMeasurementTable_get_next_data_point()";

	snmp_context_t* context = static_cast<snmp_context_t*>(*my_loop_context);
	netsnmp_variable_list *idx = put_index_data;

/* end of data points */
	if (context->gomi_it == context->gomi_list.end()) {
		DLOG(INFO) << "End of plugin instances.";
		return nullptr;
	}
	if (context->cool_it == (*context->gomi_it)->provider_->cool_.end()) {
		DLOG(INFO) << "End of client session instances.";
		return nullptr;
	}

/* this plugin instance as a data point */
	const gomi::cool_t* cool = (context->cool_it->second).get();
	const gomi::gomi_t* gomi = *context->gomi_it;

/* gomiOutageMeasurementPluginId */
	snmp_set_var_typed_value (idx, ASN_OCTET_STR, (const u_char*)gomi->plugin_id_.c_str(), gomi->plugin_id_.length());
        idx = idx->next_variable;

/* gomiOutageMeasurementClientName */
	snmp_set_var_typed_value (idx, ASN_OCTET_STR, (const u_char*)cool->GetLoginName().c_str(), cool->GetLoginName().length());

/* hunt for next valid node */
	while (++(context->cool_it) == (*context->gomi_it)->provider_->cool_.end()) {
		if (++(context->gomi_it) == context->gomi_list.end()) {
			break;
		}
		context->cool_it = (*context->gomi_it)->provider_->cool_.begin();
	}

/* reference remains in list */
        *my_data_context = (void*)cool;
	return put_index_data;
}

static
void
gomiOutageMeasurementTable_free_loop_context (
	void*			my_loop_context,
	netsnmp_iterator_info*	mydata
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != mydata);

	DLOG(INFO) << "gomiOutageMeasurementTable_free_loop_context()";

/* delete context and shared lock on global list of all gomi objects */
	snmp_context_t* context = static_cast<snmp_context_t*>(my_loop_context);
/* I'm sure there must be a better method :-( */
	snmp_context_t::global_list.erase (std::remove_if (snmp_context_t::global_list.begin(),
		snmp_context_t::global_list.end(),
		[context](std::shared_ptr<snmp_context_t>& shared_context) -> bool {
			return shared_context.get() == context;
	}));
}

/* handles requests for the gomiOutageMeasurementTable table
 */
static
int
gomiOutageMeasurementTable_handler (
	netsnmp_mib_handler*		handler,
	netsnmp_handler_registration*	reginfo,
	netsnmp_agent_request_info*	reqinfo,
	netsnmp_request_info*		requests
	)
{
	assert (nullptr != handler);
	assert (nullptr != reginfo);
	assert (nullptr != reqinfo);
	assert (nullptr != requests);

	DLOG(INFO) << "gomiOutageMeasurementTable_handler()";
	const auto now (boost::posix_time::second_clock::universal_time());

	switch (reqinfo->mode) {
        
/* Read-support (also covers GetNext requests) */

	case MODE_GET:
		for (netsnmp_request_info* request = requests;
		     request;
		     request = request->next)
		{
			const gomi::cool_t* cool = static_cast<gomi::cool_t*>(netsnmp_extract_iterator_context (request));
			if (nullptr == cool) {
				netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
				continue;
			}

			netsnmp_variable_list* var = request->requestvb;
			netsnmp_table_request_info* table_info  = netsnmp_extract_table_info (request);
			if (nullptr == table_info) {
				snmp_log (__netsnmp_LOG_ERR, "gomiOutageMeasurementTable_handler: empty table request info.\n");
				continue;
			}
    
			switch (table_info->colnum) {

			case COLUMN_GOMIACCUMULATEDOUTAGETIME:
				{
					const uint32_t outage_time = cool->GetAccumulatedOutageTime (now).total_seconds();
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&outage_time, sizeof (outage_time));
				}
				break;

			case COLUMN_GOMACCUMULATEDFAILURES:
				{
					const unsigned NAF = cool->GetAccumulatedFailures();
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&NAF, sizeof (NAF));
				}
				break;

			case COLUMN_GOMIRECORDINGSTARTTIME:
				{
					const uint32_t RST = to_unix_epoch<uint32_t> (cool->GetRecordingStartTime());
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&RST, sizeof (RST));
				}
				break;

			default:
				snmp_log (__netsnmp_LOG_ERR, "gomiOutageMeasurementTable_handler: unknown column.\n");
				netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHOBJECT);
				break;
			}
		}
		break;

	default:
		snmp_log (__netsnmp_LOG_ERR, "gomiOutageMeasurementTable_handler: unsupported mode.\n");
		break;
    }

    return SNMP_ERR_NOERROR;
}

/* Initialize the gomiOutageEventTable table by defining its contents and how it's structured
*/
static
int
initialize_table_gomiOutageEventTable(void)
{
	DLOG(INFO) << "initialize_table_gomiOutageEventTable()";

	static const oid gomiOutageEventTable_oid[] = {1,3,6,1,4,1,67,3,2,8};
	const size_t gomiOutageEventTable_oid_len = OID_LENGTH(gomiOutageEventTable_oid);
	netsnmp_handler_registration* reg = nullptr;
	netsnmp_iterator_info* iinfo = nullptr;
	netsnmp_table_registration_info* table_info = nullptr;

	reg = netsnmp_create_handler_registration (
		"gomiOutageEventTable",   gomiOutageEventTable_handler,
		gomiOutageEventTable_oid, gomiOutageEventTable_oid_len,
		HANDLER_CAN_RONLY
		);
	if (nullptr == reg)
		goto error;

	table_info = SNMP_MALLOC_TYPEDEF (netsnmp_table_registration_info);
	if (nullptr == table_info)
		goto error;
	netsnmp_table_helper_add_indexes (table_info,
					  ASN_OCTET_STR,  /* index: gomiOutageEventPluginId */
					  ASN_UNSIGNED,  /* index: gomiOutageEventId */
					  0);
	table_info->min_column = COLUMN_GOMIOUTAGECLIENTNAME;
	table_info->max_column = COLUMN_GOMIOUTAGESTATE;
    
	iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
	if (nullptr == iinfo)
		goto error;
	iinfo->get_first_data_point	= gomiOutageEventTable_get_first_data_point;
	iinfo->get_next_data_point	= gomiOutageEventTable_get_next_data_point;
	iinfo->free_loop_context_at_end = gomiOutageEventTable_free_loop_context;
	iinfo->table_reginfo		= table_info;
    
	return netsnmp_register_table_iterator (reg, iinfo);

error:
	if (table_info && table_info->indexes)		/* table_data_free_func() is internal */
		snmp_free_var (table_info->indexes);
	SNMP_FREE (table_info);
	SNMP_FREE (iinfo);
	netsnmp_handler_registration_free (reg);
	return -1;
}

/* Example iterator hook routines - using 'get_next' to do most of the work
 */
static
netsnmp_variable_list*
gomiOutageEventTable_get_first_data_point (
	void**			my_loop_context,	/* valid through one query of multiple "data points" */
	void**			my_data_context,	/* answer blob which is passed to handler() */
	netsnmp_variable_list*	put_index_data,		/* answer */
	netsnmp_iterator_info*	mydata			/* iinfo on init() */
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != my_data_context);
	assert (nullptr != put_index_data);
	assert (nullptr != mydata);

	DLOG(INFO) << "gomiOutageEventTable_get_first_data_point()";

/* Create our own context for this SNMP loop, lock on list follows lifetime of context */
	std::shared_ptr<snmp_context_t> context (new snmp_context_t (gomi::gomi_t::global_list_lock_, gomi::gomi_t::global_list_));
	if (!(bool)context || context->gomi_list.empty()) {
		DLOG(INFO) << "No plugin instances";
		return nullptr;
	}

/* Find first node, through all plugin instances. */
	for (context->gomi_it = context->gomi_list.begin();
		context->gomi_it != context->gomi_list.end();
		++(context->gomi_it))
	{
/* event recording disabled */
		if (!(bool)((*context->gomi_it)->provider_->events_)) {
			continue;
		}
		boost::shared_lock<boost::shared_mutex> lock ((*context->gomi_it)->provider_->events_lock_);
/* and through all events for each plugin provider. */
		context->event_it = (*context->gomi_it)->provider_->events_->begin();
		if (context->event_it != (*context->gomi_it)->provider_->events_->end()) {
			context->events_lock.swap (lock);
			break;
		}
	}

/* no node found. */
	if (context->gomi_it == context->gomi_list.end() ||
	    !(bool)(*context->gomi_it)->provider_->events_ ||
	    context->event_it == (*context->gomi_it)->provider_->events_->end()) {
		DLOG(INFO) << "No event instances.";
		return nullptr;
	}

/* Save context with NET-SNMP iterator. */
	*my_loop_context = context.get();
	snmp_context_t::global_list.push_back (std::move (context));

/* pass on for generic row access */
	return gomiOutageEventTable_get_next_data_point(my_loop_context, my_data_context, put_index_data, mydata);
}

static
netsnmp_variable_list*
gomiOutageEventTable_get_next_data_point (
	void**			my_loop_context,
	void**			my_data_context,
	netsnmp_variable_list*	put_index_data,
	netsnmp_iterator_info*	mydata
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != my_data_context);
	assert (nullptr != put_index_data);
	assert (nullptr != mydata);

	DLOG(INFO) << "gomiOutageEventTable_get_next_data_point()";

	snmp_context_t* context = static_cast<snmp_context_t*>(*my_loop_context);
	netsnmp_variable_list *idx = put_index_data;

/* end of data points */
	if (context->gomi_it == context->gomi_list.end()) {
		DLOG(INFO) << "End of plugin instances.";
		return nullptr;
	}
	if (!(bool)((*context->gomi_it)->provider_->events_) ||
	    context->event_it == (*context->gomi_it)->provider_->events_->end()) {
		DLOG(INFO) << "End of event instances.";
		return nullptr;
	}

/* this plugin instance as a data point */
	const gomi::event_t* event = &(*context->event_it);
	const gomi::gomi_t* gomi = *context->gomi_it;

/* gomiOutageEventPluginId */
	snmp_set_var_typed_value (idx, ASN_OCTET_STR, (const u_char*)gomi->plugin_id_.c_str(), gomi->plugin_id_.length());
        idx = idx->next_variable;

/* gomiOutageEventId */
	const unsigned event_id = event->GetIndex();
	snmp_set_var_typed_value (idx, ASN_UNSIGNED, (const u_char*)&event_id, sizeof (event_id));
        idx = idx->next_variable;

/* hunt for next valid node */
	while (++(context->event_it) == (*context->gomi_it)->provider_->events_->end()) {
		context->events_lock.unlock ();
		while (++(context->gomi_it) != context->gomi_list.end()) {
			if ((bool)(*context->gomi_it)->provider_->events_)
				break;
		}
		if (context->gomi_it == context->gomi_list.end()) {
			break;
		}
		DCHECK ((bool)((*context->gomi_it)->provider_->events_));
		boost::shared_lock<boost::shared_mutex> lock ((*context->gomi_it)->provider_->events_lock_);
		context->events_lock.swap (lock);
		context->event_it = (*context->gomi_it)->provider_->events_->begin();
	}

/* reference remains in list */
        *my_data_context = (void*)event;
	return put_index_data;
}

static
void
gomiOutageEventTable_free_loop_context (
	void*			my_loop_context,
	netsnmp_iterator_info*	mydata
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != mydata);

	DLOG(INFO) << "gomiOutageEventTable_free_loop_context()";

/* delete context and shared lock on global list of all gomi objects */
	snmp_context_t* context = static_cast<snmp_context_t*>(my_loop_context);
/* I'm sure there must be a better method :-( */
	snmp_context_t::global_list.erase (std::remove_if (snmp_context_t::global_list.begin(),
		snmp_context_t::global_list.end(),
		[context](std::shared_ptr<snmp_context_t>& shared_context) -> bool {
			return shared_context.get() == context;
	}));
}

/* handles requests for the gomiOutageEventTable table
 */
static
int
gomiOutageEventTable_handler (
	netsnmp_mib_handler*		handler,
	netsnmp_handler_registration*	reginfo,
	netsnmp_agent_request_info*	reqinfo,
	netsnmp_request_info*		requests
	)
{
	assert (nullptr != handler);
	assert (nullptr != reginfo);
	assert (nullptr != reqinfo);
	assert (nullptr != requests);

	DLOG(INFO) << "gomiOutageEventTable_handler()";

	switch (reqinfo->mode) {
        
/* Read-support (also covers GetNext requests) */

	case MODE_GET:
		for (netsnmp_request_info* request = requests;
		     request;
		     request = request->next)
		{
			const gomi::event_t* event = static_cast<gomi::event_t*>(netsnmp_extract_iterator_context (request));
			if (nullptr == event) {
				netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
				continue;
			}

			netsnmp_variable_list* var = request->requestvb;
			netsnmp_table_request_info* table_info  = netsnmp_extract_table_info (request);
			if (nullptr == table_info) {
				snmp_log (__netsnmp_LOG_ERR, "gomiOutageEventTable_handler: empty table request info.\n");
				continue;
			}
    
			switch (table_info->colnum) {
			case COLUMN_GOMIOUTAGECLIENTNAME:
				snmp_set_var_typed_value (var, ASN_OCTET_STR,
					(const u_char*)event->GetLoginName().c_str(), event->GetLoginName().length());
				break;

			case COLUMN_GOMIOUTAGESTARTTIME:
				{
					const uint32_t start_time = to_unix_epoch<uint32_t> (event->GetStartTime());
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&start_time, sizeof (start_time));
				}
				break;

			case COLUMN_GOMIOUTAGEENDTIME:
				{
					const uint32_t end_time = to_unix_epoch<uint32_t> (event->GetEndTime());
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&end_time, sizeof (end_time));
				}
				break;
            
			case COLUMN_GOMIOUTAGESTATE:
				{
					const int event_state = event->IsOnline() ? 1 : 2;
					snmp_set_var_typed_value (var, ASN_INTEGER,
						(const u_char*)&event_state, sizeof (event_state));
				}
				break;

			default:
				snmp_log (__netsnmp_LOG_ERR, "gomiOutageEventTable_handler: unknown column.\n");
				netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHOBJECT);
				break;
			}
		}
		break;

	default:
		snmp_log (__netsnmp_LOG_ERR, "gomiOutageEventTable_handler: unsupported mode.\n");
		break;
    }

    return SNMP_ERR_NOERROR;
}

} /* namespace gomi */

/* eof */